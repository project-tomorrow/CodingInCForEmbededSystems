\begin{description}
\item[1] \textsc{Compilation}
\item[Règle 1.1] Tous les fichiers sources doivent compiler sans warning.
\item[Règle 1.2] Le code est écrit et doit être compilé selon la norme C99.
\item[Règle 1.3] Il faut périodiquement lancer la toolchain cible pour s’assurer de la compatibilité avec l’environnement cible.
\item[Règle 1.4] L’utilisation de directives préprocesseurs \# pragma changeant les options de compilation devra être systématiquement documentée et justifiée.

\item[2] \textsc{Philosophie du code}
\item[Règle 2.1] Garder à tout instant à l’esprit la philosophie \og KISS  : Keep It Smart and Simple \fg{}. \linebreak
trad. \og Garde Cela Simple et Malin \fg{}
\item[Règle 2.2] \og You Ain’t Gonna Need It \fg{} est également un principe de base. \linebreak
trad. \og Tu n’en Auras Pas Besoin \fg{}
\item[Règle 2.3] Il ne doit pas y avoir de code inatteignable au sein d’un même projet.
\item[Règle 2.4] Le code mis en commentaire est interdit.

\item[3] \textsc{Organisation des fichiers sources}
\item[Règle 3.1] Toutes les précautions doivent être prises concernant l'inclusion des headers afin qu'ils ne soient pas inclus plus d'une fois dans un même objet.
\item[Règle 3.2] Tout projet doit être organisé en modules logiciels. Un module logiciel est un ensemble composé d’au moins un fichier .h et un fichier .c.
\item[Règle 3.3] Les noms des fichiers sources doivent être explicites et faire référence à l’élément du programme qu’ils concernent.
\item[Règle 3.4] Le contenu d’un fichier .h ou .c doit être cohérent d’un point de vue fonctionnel.
\item[Règle 3.5] Il est fortement souhaité que chaque fichier .h et .c contienne un cartouche descriptif du rôle du module.
\item[Règle 3.6] Les fonctions doivent posséder en en-tête un cartouche descriptif de leur rôle, leurs paramètres d’entrées-sorties et de retour ainsi qu’un bref descriptif de leur fonctionnement.

\item[4] \textsc{Directives preprocesseurs}
\item[Règle 4.1] Les \# undef sont interdits.
\item[Règle 4.2] Une macro ne doit jamais pouvoir être confondue avec une constante.
\item[Règle 4.3] On préfèrera toujours écrire une fonction plutôt qu'une macro si les deux sont interchangeables.
\item[Règle 4.4] Toute directive \# include "unFichier.h"/<unFichier.h> ne doit être précédées que par des directives préprocesseur ou des commentaires. On placera systématiquement les directives \# include en tête de fichier.
\item[Règle 4.5] Les séquences de drapeaux de compilation \# if 0 [...] \# else [...] \# endif et \# if 0 [...] \# endif sont interdites.

\item[5] \textsc{Comportement fonctionnel et mots clef du langage C}
\item[Règle 5.1] Les Digraphes et Trigraphes sont interdits.
\item[Règle 5.2] Les opérations ternaires (inline if en anglais) sont interdites.
\item[Règle 5.3] Les fonctions récursives sont interdites.
\item[Règle 5.4] Le mot clef goto est interdit.
\item[Règle 5.5] Les fonctions ou objets ne doivent pas être définis plus d'une fois.
\item[Règle 5.6] Toute occurrence d'une fonction pouvant avoir un comportement indéfini doit être encadrée afin d'être contrôlée.
\item[Règle 5.7] Il ne doit pas y avoir de conversion implicite.
\item[Règle 5.8] Il ne doit pas y avoir d'appel/définition de fonction implicite.
\item[Règle 5.9] Il ne doit pas y avoir d'allocation dynamique de mémoire.
\item[Règle 5.10] L’utilisation de fonction inline est interdite.

\item[6] \textsc{Variables}
\item[Règle 6.1] On utilisera systématiquement les types de variables permettant d'identifier leur taille et le fait qu'elles soient signées ou non.
\item[Règle 6.2] Toutes les variables, tableaux, structures et paramètres de sortie doivent êtres initialisées avant utilisation.
\item[Règle 6.3] Lors de l'initialisation par une valeur numérique d'une variable de type long le suffixe L doit être ajouté.
\item[Règle 6.4] Lors de l'initialisation par une valeur numérique d'une variable de type non signé le suffixe U doit être ajouté.

\item[7] \textsc{Style du code}
\item[Règle 7.1] La mise en page des instruction conditionnelles ou de boucles ne doit pas prêter à confusion. À cette fin, elle devra suivre la syntaxe définie.
\item[Règle 7.2a] Tous les noms de variables commencent en minuscule. Ils sont écrits en style camelCase.
\item[Règle 7.2b] Tous les noms de types commencent par une majuscule et se terminent par \_ t. Ils sont écrits en style camelCase.
\item[Règle 7.2c] Tous les noms de macro et constantes définies par \# define sont en majuscule.
\item[Règle 7.3a] Il est préférable d’utiliser // … pour les commentaires d’une ligne ou en fin de ligne.
\item[Règle 7.3b] Il est préférable d’utiliser /* … */ pour les commentaires de plus d’une ligne.
\item[Règle 7.4] L’indentation du code se fait au moyen de tabulation.
\item[Règle 7.5] Les noms de fonctions publiques d’un modules devront s’écrire [MODULE\_ TAG]\_ [nomDeFonction](...). Les fonctions internes aux modules seront laissées à la discrétion du programmeur.

\end{description}

\pagebreak