Règle 5.1 :
	

Les Digraphes et Trigraphes sont interdits.


	

Ils peuvent être remplacé par des symboles standards et ne font que rendre le code moins clair et cassent potentiellement la compilation lorsque ceux-ci sont utilisés par un programmeur qui ne les maitrise pas. De plus, ils ne sont pas supportés par certains compilateurs.


Les Digraphes sont les symboles suivants :
Correspondance digraphes <-> symboles

	
// Digraph symbol | Equivalent ASCII symbol
            <: // | [
            :> // | ]
            <% // | {
            %> // | }
            %: // | #


Trigraphes sont les symboles suivants :
Correspondance trigraphes <-> symboles
	
// Trigraph symbol | Equivalent ASCII symbol
    ??=         // | #
    ??/         // | \
    ??'         // | ^
    ??(         // | [
    ??)         // | ]
    ??!         // | |
    ??<         // | {
    ??>         // | }
    ??-         // | ~

Règle 5.2 :
	

Les opérations ternaires (inline if en anglais) sont interdites.


	

Les affectations de valeur ternaires rendent le code inutilement complexe dans sa lecture.
Exemple règle 5.2
	
/*
 * Ceci est une affectation de la valeur c ou d à la variable a selon
 * la valeur de b utilisant une opération ternaire
 */
a = b ? c : d ;
 
// On lui préfèrera toujours la forme conditionnelle ci-dessous
if( b )
{
    a = c ;
}
else
{
    a = d ;
}


Règle 5.3 :
	

Les fonctions récursives sont interdites.


	

Les fonctions récursives consomment potentiellement beaucoup de ressources en RAM et dans un contexte de développement embarqué, cela peut mener à un dépassement mémoire.

Règle 5.4 :
	

Le mot clef goto est interdit.


	

Le mot clef goto peut potentiellement induire un dysfonctionnement du programme en sautant d'une section de code à l'autre dans laquelle certaines variables ou pointeurs n'ont plus de valeur cohérente.

Exception

Si l'appel à une instruction goto est vraiment nécessaire, elle doit se faire de manière descendante dans la fonction et le code doit être commenté de façon explicite.

Règle 5.5 :
	

Les fonctions ou objets ne doivent pas être définis plus d'une fois


	

Redéfinir une fonction ou un objet amène un fort risque de télescopage à la compilation.

Règle 5.6 :
	

Toute occurrence d'une fonction pouvant avoir un comportement indéfini doit être encadrée afin d'être contrôlée.


	

Tester les paramètres pour s'assurer qu'ils sont consistant avant l'appel à une fonction pouvant avoir un comportement indéfini permet de fortement restreindre le risque de voir celui-ci se produire et nous permet de nous placer dans une optique de code robuste.

Règle 5.7 :
	

Il ne doit pas y avoir de conversion implicite.


	

Les conversions implicites provoquent des warnings.

Règle 5.8 :
	

Il ne doit pas y avoir d'appel/définition de fonction implicite.


	

Les appels/définitions de fonctions implicites signifient qu'un module du programme n'est pas visible depuis le module courant ou qu'une onction n'est pas définie correctement. Cela provoque l'apparition de warnings

Règle 5.9 :
	

Les allocations dynamiques de mémoire sont interdite.


	

Les allocations dynamiques de mémoire sont des procédures risquées dans un cadre embarqués et peuvent être éviter en dimensionnant correctement la taille des piles allouées à chaque tache lors de la conception.

Règle 5.10 :
	

L'utilisation de fonction inline est interdite.


	

L'utilisation de fonctions inline duplique le code lors de la compilation et en augmente la taille finale dans un contexte où il est nécessaire de faire des économies de mémoire.